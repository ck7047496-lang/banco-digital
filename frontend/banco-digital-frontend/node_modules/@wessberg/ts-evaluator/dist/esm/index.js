import * as TSModule from 'typescript';
import { has, get, set, del } from 'object-path';
import { dirname } from 'path';
import { JSDOM } from 'jsdom';
import { __rest, __decorate, __param } from 'tslib';
import chalk from 'chalk';
import { inspect } from 'util';

/**
 * Returns true if the provided value is ObjectLike
 *
 * @param value
 * @returns
 */
function isObjectLike(value) {
    return value != null && (typeof value === "function" || typeof value === "object");
}
/**
 * Returns true if the given value can be observed
 *
 * @param value
 * @returns
 */
function canBeObserved(value) {
    return isObjectLike(value);
}

/**
 * Returns true if the given function is either Function.prototype.bind, Function.prototype.call, or Function.prototype.apply
 *
 * @param func
 * @param [environment]
 * @return
 */
function isBindCallApply(func, environment) {
    switch (func) {
        case Function.prototype.bind:
        case Function.prototype.call:
        case Function.prototype.apply:
            return true;
    }
    if (environment != null) {
        const _Function = getFromLexicalEnvironment(undefined, environment, "Function").literal;
        switch (func) {
            case _Function.prototype.bind:
            case _Function.prototype.call:
            case _Function.prototype.apply:
                return true;
        }
    }
    return false;
}

/* eslint-disable @typescript-eslint/ban-types */
/**
 * Stringifies the given PropertyKey path
 */
function stringifyPath(path) {
    return path.map(part => (typeof part === "symbol" ? part.description : part)).join(".");
}
/**
 * Creates a proxy with hooks to check the given policy
 */
function createPolicyProxy({ hook, item, scope, policy }) {
    /**
     * Creates a trap that captures function invocation
     */
    function createAccessTrap(inputPath, currentItem) {
        return !canBeObserved(currentItem) || isBindCallApply(currentItem)
            ? currentItem
            : new Proxy(currentItem, {
                /**
                 * Constructs a new instance of the given target
                 */
                construct(target, argArray, newTarget) {
                    // Don't proceed if the hook says no
                    if (!hook({
                        kind: "__$$_PROXY_CONSTRUCT" /* CONSTRUCT */,
                        policy,
                        newTarget,
                        argArray,
                        target,
                        path: stringifyPath(inputPath)
                    })) {
                        return {};
                    }
                    return Reflect.construct(target, argArray, newTarget);
                },
                /**
                 * A trap for a function call. Used to create new proxies for methods on the retrieved module objects
                 */
                apply(target, thisArg, argArray = []) {
                    // Don't proceed if the hook says no
                    if (!hook({
                        kind: "__$$_PROXY_APPLY" /* APPLY */,
                        policy,
                        thisArg,
                        argArray,
                        target,
                        path: stringifyPath(inputPath)
                    })) {
                        return;
                    }
                    return Reflect.apply(target, thisArg, argArray);
                },
                /**
                 * Gets a trap for 'get' accesses
                 */
                get(target, property, receiver) {
                    const newPath = [...inputPath, property];
                    // Don't proceed if the hook says no
                    if (!hook({
                        kind: "__$$_PROXY_GET" /* GET */,
                        policy,
                        path: stringifyPath(newPath),
                        target
                    })) {
                        return;
                    }
                    const match = Reflect.get(target, property, receiver);
                    const config = Reflect.getOwnPropertyDescriptor(currentItem, property);
                    if (config != null && config.configurable === false && config.writable === false) {
                        return currentItem[property];
                    }
                    return createAccessTrap(newPath, match);
                }
            });
    }
    return !canBeObserved(item) ? item : createAccessTrap([scope], item);
}

/**
 * Stringifies the given PolicyTrapKind on the given path
 *
 * @param kind
 * @param path
 * @return
 */
function stringifyPolicyTrapKindOnPath(kind, path) {
    switch (kind) {
        case "__$$_PROXY_GET" /* GET */:
            return `get ${path}`;
        case "__$$_PROXY_APPLY" /* APPLY */:
            return `${path}(...)`;
        case "__$$_PROXY_CONSTRUCT" /* CONSTRUCT */:
            return `new ${path}(...)`;
    }
}

/**
 * A Map between built-in modules and the kind of IO operations their members performs
 * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}
 */
const NETWORK_MAP = {
    http2: {
        connect: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        createSecureServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        createServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        }
    },
    https: {
        createServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        request: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        get: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        Server: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        },
        globalAgent: {
            destroy: {
                ["__$$_PROXY_APPLY" /* APPLY */]: true
            }
        },
        Agent: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        }
    },
    http: {
        createServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        request: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        get: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        Server: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        },
        ClientRequest: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        },
        globalAgent: {
            destroy: {
                ["__$$_PROXY_APPLY" /* APPLY */]: true
            }
        },
        Agent: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        }
    },
    dgram: {
        createSocket: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        }
    },
    dns: {
        lookup: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        lookupService: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolve: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolve4: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolve6: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveAny: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveCname: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveMx: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveNaptr: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveNs: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolvePtr: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveSoa: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveSrv: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        resolveTxt: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        reverse: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        Resolver: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        }
    },
    net: {
        createServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        createConnection: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        connect: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        Server: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        }
    },
    tls: {
        createServer: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        createSecureContext: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        connect: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        Server: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        },
        TLSSocket: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: true
        }
    }
};

/**
 * A Map between built-in identifiers and the members that produce non-deterministic results.
 * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}
 */
const NONDETERMINISTIC_MAP = Object.assign(Object.assign({}, NETWORK_MAP), { Math: {
        random: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        }
    }, Date: {
        now: {
            ["__$$_PROXY_APPLY" /* APPLY */]: true
        },
        // Dates that receive no arguments are nondeterministic since they care about "now" and will evaluate to a new value for each invocation
        ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: (...args) => args.length === 0 && !(args[0] instanceof Date)
    } });

/**
 * Returns true if the given item is a TrapCondition
 *
 * @param item
 * @param condition
 * @return
 */
function isTrapCondition(item, condition) {
    // noinspection SuspiciousTypeOfGuard
    return typeof item === typeof condition || typeof item === "function";
}
/**
 * Returns true if the given item is a TrapCondition
 *
 * @param item
 * @return
 */
function isTrapConditionFunction(item) {
    return typeof item === "function";
}

/* eslint-disable @typescript-eslint/ban-types */
/**
 * Returns true if the given path represents something that is nondeterministic.
 *
 * @param map
 * @param condition
 * @param item
 * @returns
 */
function isTrapConditionMet(map, condition, item) {
    const atoms = item.path.split(".");
    return walkAtoms(map, condition, item, atoms);
}
/**
 * Walks all atoms of the given item path
 *
 * @param map
 * @param matchCondition
 * @param item
 * @param atoms
 * @return
 */
function walkAtoms(map, matchCondition, item, atoms) {
    const [head, ...tail] = atoms;
    if (head == null)
        return false;
    const mapEntry = map[head];
    // If nothing was matched within the namespace, the trap wasn't matched
    if (mapEntry == null)
        return false;
    if (isTrapCondition(mapEntry, matchCondition)) {
        return handleTrapCondition(mapEntry, matchCondition, item);
    }
    else {
        const trapMapMatch = mapEntry[item.kind];
        if (trapMapMatch != null) {
            return handleTrapCondition(trapMapMatch, matchCondition, item);
        }
        else {
            return walkAtoms(mapEntry, matchCondition, item, tail);
        }
    }
}
/**
 * Handles a TrapCondition
 *
 * @param trapCondition
 * @param matchCondition
 * @param item
 * @return
 */
function handleTrapCondition(trapCondition, matchCondition, item) {
    // If matching the condition depends on the provided arguments, pass them in
    if (isTrapConditionFunction(trapCondition)) {
        const castItem = item;
        return trapCondition(...castItem.argArray) === matchCondition;
    }
    // Otherwise, evaluate the truthiness of the condition
    else {
        return trapCondition === matchCondition;
    }
}

/**
 * Returns true if the given path represents something that is nondeterministic.
 *
 * @param item
 * @returns
 */
function isNonDeterministic(item) {
    return isTrapConditionMet(NONDETERMINISTIC_MAP, true, item);
}

/**
 * A Base class for EvaluationErrors
 */
class EvaluationError extends Error {
    constructor({ node, message }) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.node = node;
    }
}

/**
 * An Error that can be thrown when a policy is violated
 */
class PolicyError extends EvaluationError {
    constructor({ violation, node, message }) {
        super({ node, message: `[${violation}]: ${message}` });
        this.violation = violation;
    }
}

/**
 * An Error that can be thrown when something nondeterministic is attempted to be evaluated and has been disallowed to be so
 */
class NonDeterministicError extends PolicyError {
    constructor({ operation, node, message = `The operation: '${operation}' is nondeterministic. That is in violation of the policy` }) {
        super({ violation: "deterministic", message, node });
        this.operation = operation;
    }
}

/**
 * A Map between built-in modules and the kind of IO operations their members performs
 * @type {TrapConditionMap<NodeBuiltInsAndGlobals, "read"|"write">}
 */
const IO_MAP = {
    fs: {
        readFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        readFileSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        readdir: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        readdirSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        read: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        readSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        exists: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        existsSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        access: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        accessSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        close: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        closeSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        createReadStream: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        stat: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        statSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        watch: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        watchFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        unwatchFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        realpath: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        realpathSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        fstat: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        fstatSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "read"
        },
        createWriteStream: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        copyFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        copyFileSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        unlink: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        unlinkSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        rmdir: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        rmdirSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        symlink: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        symlinkSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        truncate: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        truncateSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        utimes: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        utimesSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        appendFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        appendFileSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        write: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        writeSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        writeFile: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        writeFileSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        chmod: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        chmodSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        chown: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        chownSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        mkdir: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        mkdirSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        rename: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        renameSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        futimes: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        futimesSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        link: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        linkSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        mkdtemp: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        open: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        openSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fchmod: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fchmodSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fchown: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fchownSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        ftruncate: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        ftruncateSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fsync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fsyncSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fdatasync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        fdatasyncSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        lchmod: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        },
        lchmodSync: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "write"
        }
    }
};

/**
 * Returns true if the given member represents a READ operation from IO
 *
 * @param item
 * @returns
 */
function isIoRead(item) {
    return isTrapConditionMet(IO_MAP, "read", item);
}

/**
 * An Error that can be thrown when an IO operation is attempted to be executed that is in violation of the context policy
 */
class IoError extends PolicyError {
    constructor({ node, kind, message = `${kind} operations are in violation of the policy` }) {
        super({ violation: "io", message, node });
        this.kind = kind;
    }
}

/**
 * Returns true if the given member represents a WRITE operation from IO
 *
 * @param item
 * @returns
 */
function isIoWrite(item) {
    return isTrapConditionMet(IO_MAP, "write", item);
}

/**
 * Returns true if the given item represents a network operation
 *
 * @param item
 * @returns
 */
function isNetworkOperation(item) {
    return isTrapConditionMet(NETWORK_MAP, true, item);
}

/**
 * An Error that can be thrown when a network operation is attempted to be executed that is in violation of the context policy
 */
class NetworkError extends PolicyError {
    constructor({ operation, node, message = `The operation: '${operation}' is performing network activity. That is in violation of the policy` }) {
        super({ violation: "deterministic", message, node });
        this.operation = operation;
    }
}

/**
 * A Map between built-in modules (as well as 'process' and the kind of IO operations their members performs
 * @type {TrapConditionMap<NodeBuiltInsAndGlobals, string>}
 */
const PROCESS_MAP = {
    process: {
        exit: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "exit"
        }
    },
    // Everything inside child_process is just one big violation of this policy
    child_process: {
        ["__$$_PROXY_APPLY" /* APPLY */]: "spawnChild"
    },
    cluster: {
        fork: {
            ["__$$_PROXY_APPLY" /* APPLY */]: "spawnChild"
        },
        worker: {
            ["__$$_PROXY_GET" /* GET */]: "spawnChild"
        },
        Worker: {
            ["__$$_PROXY_CONSTRUCT" /* CONSTRUCT */]: "spawnChild"
        },
        workers: {
            ["__$$_PROXY_GET" /* GET */]: "spawnChild"
        }
    }
};

/**
 * Returns true if the given item represents a process operation that exits the process
 *
 * @param item
 * @returns
 */
function isProcessExitOperation(item) {
    return isTrapConditionMet(PROCESS_MAP, "exit", item);
}

/**
 * An Error that can be thrown when a Process operation is attempted to be executed that is in violation of the context policy
 */
class ProcessError extends PolicyError {
    constructor({ kind, node, message = `${kind} operations are in violation of the policy` }) {
        super({ violation: "process", message, node });
        this.kind = kind;
    }
}

/**
 * Returns true if the given item represents a process operation that spawns a child
 *
 * @param item
 * @returns
 */
function isProcessSpawnChildOperation(item) {
    return isTrapConditionMet(PROCESS_MAP, "spawnChild", item);
}

/**
 * A Map between built-in modules (as well as 'console' and the operations that print to console
 * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}
 */
const CONSOLE_MAP = {
    console: {
        ["__$$_PROXY_APPLY" /* APPLY */]: true
    }
};

/**
 * Returns true if the given item represents an operation that prints to console
 *
 * @param item
 * @returns
 */
function isConsoleOperation(item) {
    return isTrapConditionMet(CONSOLE_MAP, true, item);
}

/**
 * Creates an environment that provide hooks into policy checks
 */
function createSanitizedEnvironment({ policy, env, getCurrentNode }) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const hook = (item) => {
        if (!policy.console && isConsoleOperation(item)) {
            return false;
        }
        if (!policy.io.read && isIoRead(item)) {
            throw new IoError({ kind: "read", node: getCurrentNode() });
        }
        if (!policy.io.write && isIoWrite(item)) {
            throw new IoError({ kind: "write", node: getCurrentNode() });
        }
        if (!policy.process.exit && isProcessExitOperation(item)) {
            throw new ProcessError({ kind: "exit", node: getCurrentNode() });
        }
        if (!policy.process.exit && isProcessSpawnChildOperation(item)) {
            throw new ProcessError({ kind: "spawnChild", node: getCurrentNode() });
        }
        if (!policy.network && isNetworkOperation(item)) {
            throw new NetworkError({ operation: stringifyPolicyTrapKindOnPath(item.kind, item.path), node: getCurrentNode() });
        }
        if (policy.deterministic && isNonDeterministic(item)) {
            throw new NonDeterministicError({ operation: stringifyPolicyTrapKindOnPath(item.kind, item.path), node: getCurrentNode() });
        }
        return true;
    };
    const descriptors = Object.entries(Object.getOwnPropertyDescriptors(env));
    const gettersAndSetters = Object.assign({}, ...descriptors.filter(([, descriptor]) => !("value" in descriptor)).map(([name, descriptor]) => ({ [name]: descriptor })));
    const values = Object.assign({}, ...descriptors
        .filter(([, descriptor]) => "value" in descriptor)
        .map(([name, descriptor]) => ({
        [name]: name === "require"
            ? new Proxy(descriptor.value, {
                /**
                 * A trap for a function call. Used to create new proxies for methods on the retrieved module objects
                 *
                 * @param target
                 * @param thisArg
                 * @param argArray
                 * @return
                 */
                apply(target, thisArg, argArray = []) {
                    const [moduleName] = argArray;
                    return createPolicyProxy({
                        policy,
                        item: Reflect.apply(target, thisArg, argArray),
                        scope: moduleName,
                        hook
                    });
                }
            })
            : createPolicyProxy({
                policy,
                item: descriptor.value,
                scope: name,
                hook
            })
    })));
    return Object.defineProperties(values, Object.assign({}, gettersAndSetters));
}

const ECMA_GLOBALS = () => {
    /* eslint-disable @typescript-eslint/naming-convention */
    const base = {
        Infinity,
        NaN,
        undefined,
        isNaN,
        parseFloat,
        parseInt,
        decodeURI,
        decodeURIComponent,
        encodeURI,
        encodeURIComponent,
        Array,
        Boolean,
        Date,
        Error,
        EvalError,
        Number,
        Object,
        RangeError,
        ReferenceError,
        RegExp,
        String,
        SyntaxError,
        TypeError,
        URIError,
        JSON,
        Math,
        escape,
        unescape,
        // eslint-disable-next-line no-eval
        eval,
        Function
        /* eslint-enable @typescript-eslint/naming-convention */
    };
    try {
        base.BigInt = BigInt;
    }
    catch (_a) { }
    try {
        base.Reflect = Reflect;
    }
    catch (_b) { }
    try {
        base.WeakMap = WeakMap;
    }
    catch (_c) { }
    try {
        base.WeakSet = WeakSet;
    }
    catch (_d) { }
    try {
        base.Set = Set;
    }
    catch (_e) { }
    try {
        base.Map = Map;
    }
    catch (_f) { }
    try {
        base.Uint8Array = Uint8Array;
    }
    catch (_g) { }
    try {
        base.Uint8ClampedArray = Uint8ClampedArray;
    }
    catch (_h) { }
    try {
        base.Uint16Array = Uint16Array;
    }
    catch (_j) { }
    try {
        base.Uint32Array = Uint32Array;
    }
    catch (_k) { }
    try {
        base.Intl = Intl;
    }
    catch (_l) { }
    try {
        base.Int8Array = Int8Array;
    }
    catch (_m) { }
    try {
        base.Int16Array = Int16Array;
    }
    catch (_o) { }
    try {
        base.Int32Array = Int32Array;
    }
    catch (_p) { }
    try {
        base.Float32Array = Float32Array;
    }
    catch (_q) { }
    try {
        base.Float64Array = Float64Array;
    }
    catch (_r) { }
    try {
        base.ArrayBuffer = ArrayBuffer;
    }
    catch (_s) { }
    try {
        base.DataView = DataView;
    }
    catch (_t) { }
    try {
        base.isFinite = isFinite;
    }
    catch (_u) { }
    try {
        base.Promise = Promise;
    }
    catch (_v) { }
    try {
        base.Proxy = Proxy;
    }
    catch (_w) { }
    try {
        base.Symbol = Symbol;
    }
    catch (_x) { }
    return base;
};

/* eslint-disable @typescript-eslint/ban-types */
function mergeDescriptors(a, b, c) {
    const newObj = {};
    const normalizedB = b == null ? {} : b;
    const normalizedC = c == null ? {} : c;
    [a, normalizedB, normalizedC].forEach(item => Object.defineProperties(newObj, Object.getOwnPropertyDescriptors(item)));
    return newObj;
}

/* eslint-disable @typescript-eslint/ban-types */
/**
 * Excludes the properties of B from A
 */
function subtract(a, b) {
    const newA = {};
    Object.getOwnPropertyNames(a).forEach(name => {
        if (!(name in b)) {
            Object.defineProperty(newA, name, Object.getOwnPropertyDescriptor(a, name));
        }
    });
    return newA;
}

const NODE_GLOBALS = () => {
    const ecmaGlobals = ECMA_GLOBALS();
    const merged = mergeDescriptors(subtract(global, ecmaGlobals), ecmaGlobals, {
        require,
        __dirname: (fileName) => dirname(fileName),
        __filename: (fileName) => fileName
    });
    Object.defineProperties(merged, {
        global: {
            get() {
                return merged;
            }
        },
        globalThis: {
            get() {
                return merged;
            }
        }
    });
    return merged;
};

var EnvironmentPresetKind;
(function (EnvironmentPresetKind) {
    EnvironmentPresetKind["NONE"] = "NONE";
    EnvironmentPresetKind["ECMA"] = "ECMA";
    EnvironmentPresetKind["BROWSER"] = "BROWSER";
    EnvironmentPresetKind["NODE"] = "NODE";
})(EnvironmentPresetKind || (EnvironmentPresetKind = {}));

/**
 * Returns an object containing the properties that are relevant to 'requestAnimationFrame' and 'requestIdleCallback'
 */
function rafImplementation(global) {
    let lastTime = 0;
    const _requestAnimationFrame = function requestAnimationFrame(callback) {
        const currTime = new Date().getTime();
        const timeToCall = Math.max(0, 16 - (currTime - lastTime));
        const id = global.setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
    const _cancelAnimationFrame = function cancelAnimationFrame(id) {
        clearTimeout(id);
    };
    return {
        requestAnimationFrame: _requestAnimationFrame,
        cancelAnimationFrame: _cancelAnimationFrame
    };
}

const BROWSER_GLOBALS = () => {
    const { window } = new JSDOM("", { url: "https://example.com" });
    const ecmaGlobals = ECMA_GLOBALS();
    const raf = rafImplementation(window);
    const merged = mergeDescriptors(subtract(window, ecmaGlobals), subtract(raf, window), ecmaGlobals);
    Object.defineProperties(merged, {
        window: {
            get() {
                return merged;
            }
        },
        globalThis: {
            get() {
                return merged;
            }
        }
    });
    return merged;
};

const RETURN_SYMBOL = "[return]";

const BREAK_SYMBOL = "[break]";

const CONTINUE_SYMBOL = "[continue]";

const THIS_SYMBOL = "this";

const SUPER_SYMBOL = "super";

/**
 * Gets a value from a Lexical Environment
 *
 * @param env
 * @param path
 * @returns
 */
function getRelevantDictFromLexicalEnvironment(env, path) {
    const [firstBinding] = path.split(".");
    if (has(env.env, firstBinding))
        return env.env;
    if (env.parentEnv != null)
        return getRelevantDictFromLexicalEnvironment(env.parentEnv, path);
    return undefined;
}
/**
 * Gets the EnvironmentPresetKind for the given LexicalEnvironment
 */
function getPresetForLexicalEnvironment(env) {
    if (env.preset != null)
        return env.preset;
    else if (env.parentEnv != null)
        return getPresetForLexicalEnvironment(env.parentEnv);
    else
        return EnvironmentPresetKind.NONE;
}
/**
 * Gets a value from a Lexical Environment
 */
function getFromLexicalEnvironment(node, env, path) {
    const [firstBinding] = path.split(".");
    if (has(env.env, firstBinding)) {
        const literal = get(env.env, path);
        switch (path) {
            // If we're in a Node environment, the "__dirname" and "__filename" meta-properties should report the current directory or file of the SourceFile and not the parent process
            case "__dirname":
            case "__filename": {
                const preset = getPresetForLexicalEnvironment(env);
                return preset === EnvironmentPresetKind.NODE && typeof literal === "function" && node != null ? { literal: literal(node.getSourceFile().fileName) } : { literal };
            }
            default:
                return { literal };
        }
    }
    if (env.parentEnv != null)
        return getFromLexicalEnvironment(node, env.parentEnv, path);
    return undefined;
}
/**
 * Returns true if the given lexical environment contains a value on the given path that equals the given literal
 */
function pathInLexicalEnvironmentEquals(node, env, equals, ...matchPaths) {
    return matchPaths.some(path => {
        const match = getFromLexicalEnvironment(node, env, path);
        return match == null ? false : match.literal === equals;
    });
}
/**
 * Returns true if the given value represents an internal symbol
 *
 * @param value
 * @return
 */
function isInternalSymbol(value) {
    switch (value) {
        case RETURN_SYMBOL:
        case BREAK_SYMBOL:
        case CONTINUE_SYMBOL:
        case THIS_SYMBOL:
        case SUPER_SYMBOL:
            return true;
        default:
            return false;
    }
}
/**
 * Gets a value from a Lexical Environment
 *
 * @param options
 * @param [newBinding=false]
 */
function setInLexicalEnvironment({ env, path, value, reporting, node, newBinding = false }) {
    const [firstBinding] = path.split(".");
    if (has(env.env, firstBinding) || newBinding || env.parentEnv == null) {
        // If the value didn't change, do no more
        if (has(env.env, path) && get(env.env, path) === value)
            return;
        // Otherwise, mutate it
        set(env.env, path, value);
        // Inform reporting hooks if any is given
        if (reporting.reportBindings != null && !isInternalSymbol(path)) {
            reporting.reportBindings({ path, value, node });
        }
    }
    else {
        let currentParentEnv = env.parentEnv;
        while (currentParentEnv != null) {
            if (has(currentParentEnv.env, firstBinding)) {
                // If the value didn't change, do no more
                if (has(currentParentEnv.env, path) && get(currentParentEnv.env, path) === value)
                    return;
                // Otherwise, mutate it
                set(currentParentEnv.env, path, value);
                // Inform reporting hooks if any is given
                if (reporting.reportBindings != null && !isInternalSymbol(path)) {
                    reporting.reportBindings({ path, value, node });
                }
                return;
            }
            else {
                currentParentEnv = currentParentEnv.parentEnv;
            }
        }
    }
}
/**
 * Clears a binding from a Lexical Environment
 *
 * @param env
 * @param path
 */
function clearBindingFromLexicalEnvironment(env, path) {
    const [firstBinding] = path.split(".");
    if (has(env.env, firstBinding)) {
        del(env.env, path);
    }
    else {
        let currentParentEnv = env.parentEnv;
        while (currentParentEnv != null) {
            if (has(currentParentEnv.env, firstBinding)) {
                del(currentParentEnv.env, path);
                return;
            }
            else {
                currentParentEnv = currentParentEnv.parentEnv;
            }
        }
    }
}
/**
 * Creates a Lexical Environment
 *
 * @param options
 * @returns
 */
function createLexicalEnvironment({ inputEnvironment: { extra, preset }, policy, getCurrentNode }) {
    let envInput;
    switch (preset) {
        case EnvironmentPresetKind.NONE:
            envInput = mergeDescriptors(extra);
            break;
        case EnvironmentPresetKind.ECMA:
            envInput = mergeDescriptors(ECMA_GLOBALS(), extra);
            break;
        case EnvironmentPresetKind.NODE:
            envInput = mergeDescriptors(NODE_GLOBALS(), extra);
            break;
        case EnvironmentPresetKind.BROWSER:
            envInput = mergeDescriptors(BROWSER_GLOBALS(), extra);
            break;
        default:
            envInput = {};
            break;
    }
    return {
        preset,
        parentEnv: undefined,
        env: createSanitizedEnvironment({
            policy,
            env: envInput,
            getCurrentNode
        })
    };
}

/**
 * Returns true if the given node is a BooleanLiteral
 */
function isBooleanLiteral(node, typescript) {
    return node.kind === typescript.SyntaxKind.TrueKeyword || node.kind === typescript.SyntaxKind.FalseKeyword;
}

/**
 * Returns true if the given node is a NullLiteral
 */
function isNullLiteral(node, typescript) {
    return node.kind === typescript.SyntaxKind.NullKeyword;
}

/**
 * This is a tiny function that avoids the costs of building up an evaluation environment
 * for the interpreter. If the node is a simple literal, it will return its' value.
 */
function evaluateSimpleLiteral(node, typescript) {
    var _a;
    if (typescript.isStringLiteralLike(node))
        return { success: true, value: node.text 